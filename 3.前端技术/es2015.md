[toc]

# 文档
1. https://babeljs.io/learn-es2015/

# let
声明一个变量，let引入块级作用域，let在块级作用域中声明的变量仅在块级作用域中有效

# const
声明一个常量，常量值不能改变

# class
es2015定义了类的实现
``` js
class InheritClass extends BaseClass {
    constructor() { //构造函数
        super(); //先调用父类的构造函数
        //实现子类的构造函数
        //this表示本对象
        
        // 属性定义
    }
    
    update(camera) {
        super.update()
        // do with camera
    }
    
    // getter方法，用于拦截属性读取，value = ins.prop1
    get prop1() {return "prop value";}
    
    // setter方法，用于拦截属性设置，ins.prop1 = value
    set prop1(value) {this.prop1 = value;}
    
    // 静态方法
    static staticMethod() {}
    
    /// 另一种定义属性和方法的方式 ///
    // 定义属性
    prop2 = 2;
    
    // 定义方法(此法绑定了this)
    method2 = (args) => {}
}
```

# arrow function
函数表示`(args) => {body}`

箭头函数中的this指的是定义函数时的对象，而不是使用函数时的对象，这个功能可以免于对函数绑定this
```
eg1. (i) => i+1
eg2. (x, y) => {x++; y--; return x+y}
```

# template string
使用反引号==反引号==来标记，使用${}来引用变量，字符串中的空格缩进都会被保留在输出中
```
eg. var str = `my name is ${me.name}, age is ${me.age}`;
```

# destructuring
解构，从数组和对象中提取值
```
let cat = 'ken', dog = 'lili';
let zoo = {cat: cat, dog: dog} 等同于 let zoo = {cat, dog};
console.log(zoo); // Object {cat: 'ken', dog: 'lili'}
```

反过来

```
let dog = {type: 'animal', many: 2};
let {type, many} = dog;
console.log(type, many) //animal 2
```

# default
函数可以指定默认值，而不用进行如 `type = type || 'cat'`等判断
```
eg1. function animal(type = 'cat') { console.log(type) }
```

# rest
剩下不定参数的数组，类似arguments
```
function animail(...types) { console.log(types) }
animail('cat', 'dog', 'fish'); // ['cat', 'dog', 'fish']
```

# spread
rest参数的逆运算，将数组展开
```
eg. console.log(...[1, 2, 4]) // 1 2 3
```

# export
导出类，函数， 变量等，一个模块可导出多个
```
// m1.js
export default const str = 'hello world'; //默认导出一个模块只能有一个
export function f1(a) {return a + 1}
export const str1 = 'str1'
```

另一种写法 
```
export {str as default, f1, str1}
```

# import
导入类，函数，变量等
```
import str from 'm1.js' //导入默认，不需要大括号
import {f1, str1} from 'm1.js' //
```
非默认导入需要加大括号，变量名与模块中的导出名一致
另一种写法 
```
import str, {f1 as xx, str1} from 'm1.js'
import str, * as obj from 'm1.js' // 非默认导出放到对象obj上。
```

# promise
用同步的方式写异步代码，promise的状态，pending, resolved, rejected，状态只改变一次就固定下来

```
p = new Promise((resolve, reject) => {
    // 这里是异步操作的工作函数，当成功或失败时通过resolve或reject通知
    if (success) {
        resolve(data); // pending->resolved, 成功时调用，data会传给then的第一个回调
    } else {
        reject(error); // pending->rejected, 失败时调用，error会传给then的第二个回调
    }
});

p.then(
    data => {console.log("success callback")}, // promise执行成功时的回调
    error => {console.log("error callback")} // promise执行失败时的回调(可选)
).catch(
    // 捕捉promise和then中的错误，因此一般不写then的reject回调，统一用catch处理
    //使用reject回调和throw的作用是相同的，catch也可以抛出异常，因此可以有多个catch
    error => {console.log("error callback")}
);

// 一个promise对象只有一个then和catch，then和catch又返回一个新的promise对象，
// 因此可以进行链式调用，上一个then/catch返回的数据会做为参数触发新promise的resolve/reject.
// 如果上一个then/catch返回的是一个promise，那么这个promise状态改变时触发新的then/catch.
p.then(
    (data) => {}
).catch(
    (error) => {}
).then(
    (data) => {}
).catch(
    (error) => {}
)
```


# generators
```
function *createGenerator() {
    yield 1;
    yield 2;
    yield 3;
}
```

